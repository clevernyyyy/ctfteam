# dyrpto

## Some regrets :(
I had a silly error where was computing ```id_delta``` based on ```len(str) == 271``` instead of ```len(message.SerializeToString()) == 271```. I realized this after stepping away from the computer after the CTF had closed. :(

## Description

### Story
You decide to return to the Carnival to see if you can find the fortune teller again. As you’re searching, you mull over the fortune teller's words, “swollen tongue… jumbled vision… burning rubber… a bark… waves passing…”, and you trip over a dog beneath your feet. It’s a black dog, pointy ears, a little scruffy. A scottish terrier! How cute.

The dog looks at you and you look back at the dog. It’s small and its tail is wagging. It seems not at all out of place among the hustle and bustle of Carnival. You squat down and reach your hand out.

“Here doggy. Nice doggy.”

The dog comes forward and sniffs your hand, allowing you to give him a scratch on the head. As you continue to scratch, you feel something remarkably smooth. You wonder what it could be. You bend over to take a closer look and the dog senses your interest, tensing. Just as you’re about to pull a flag out of its collar, it pulls free of your grip and darts away.

“Hey! Come back, doggy.”

You begin to chase after it, but lose the dog in the crowd. To your surprise, you discover a sheet of paper left in your hand. You see that most of it is torn off, but it looks like the beginning of something useful. Looking around again, you spot the scotty dog and dash after it.

### Problem Details
<a href="./dyrpto.tar.gz" download>Download</a>


## Solution

### Examining the contents

Top of the script made it pretty clear that this is a RSA problem, the public exponent (e) is 3, and the keysize is 4096 bits.
```Python
from cryptography.hazmat.backends.openssl import backend as openssl_backend
from cryptography.hazmat.primitives.asymmetric.rsa import generate_private_key
import json

from message_pb2 import Message

privkey = generate_private_key(3, 4096, openssl_backend)
pubkey = privkey.public_key()
pubkey_numbers = pubkey.public_numbers()
modulus = pubkey_numbers.n
publicExponent = pubkey_numbers.e
privateExponent = privkey.private_numbers().d
```


Bottom of the script revealed how the contents of output.txt was generated:
```Python
message = Message(id=0, msg=flag_message)
ct1 = encrypt(message.SerializeToString())
message.id = 1
ct2 = encrypt(message.SerializeToString())
print modulus
print len(message.SerializeToString())
print ct1.encode('hex')
print ct2.encode('hex')
```

output.txt
```
647353081512155557435109029192899887292162896024387438380717904550049084072650858042487538260409968902476642050863551118537014801984015026845895208603765204484721851898066687201063160748700966276614009722396362475860673283467894418696897868921145204864477937433189412833621006424924922775206256529053118483685827144126396074730453341509096269922609997933482099350967669641747655782027157871050452284368912421597547338355164717467365389718512816843810112610151402293076239928228117824655751702578849364973841428924562822833982858491919896776037660827425125378364372495534346479756462737760465746815636952287878733868933696188382829432359669960220276553567701006464705764781429964667541930625224157387181453452208309282139359638193440050826441444111527140592168826430470521828807532468836796445893725071942672574028431402658126414443737803009580768987541970193759730480278307362216692962285353295300391148856280961671861600486447754303730588822350406393620332040359962142016784588854071738540262784464951088700157947527856905149457353587048951604342248422901427823202477854550861884781719173510697653413351949112195965316483043418797396717013675120500373425502099598874281334096073572424550878063888692026422588022920084160323128550629
271
314193fd72359213463d75b4fc6db85de0a33b8098ba0ba98a215f246e7f6c4d17b59abb7e4ceb824d7310056d6574b13956f1b3d1ac868b72f6b98508b586566d71474da72c2ae4d3273c80757d0160f703ca0b14a0504509d92d4c09a733feae349a5b512fdcea46574a29b8507c60b5c49edd7641b19f98845688c38fc67a35432653140cbb5abc17d3c32f3720e4549797877ca9cae61aa75df936e41200906729a0dac3b7b18289681dbaf4a3bfdf9a3acf2efac8c5e5f873ede32ccbfcae438bd813601f4fe5290f2b999d988f3d0f423d76a6ae8a5dee2dd17aa7996e8f96fe9c76ac379f6dabb6def2dc05c8561fad1722706736aba8a20385d2054e1929682157f1d201b22a224aafb6004164f3325124279e16c99471a341b88300bd0161cdeca4b9d92bf761a0ed74c2b151a62d10c4b0cdbd3e8f657f76f3ac88430a4a89ab4a913d9a55dae150b6e42df6e161382055782c0ff05e635fb2e50e826f08440266dc60ca081b1d17c18145c6d45a1fa0bb439428e4796346bc912e897897dc47097d0047b28e0ff1e52ea27726ce444b1287b250ed5a43a2e84c37cba4c2e39b5c389d671c0ea0639d3a2c6092cc1ee50e35c810eb5d053190d7594c52995ac95b7889a61d2afe7d6dc33b0e13ab4eddd791f01a11b336549154bb894b5afc0dcc5b5b4ce9f162f423b7dd80ce70a73ddbda0333c12eeea408e97c
0b9bbdf92c4c5099708b911813737e3f17ef3d554bceb65d2681b377a2c5bdb8f1c634602bda2ec9b2b7b6f894f1592c944865594740e9fd139d07db9d309a93d2a33ec3a0455acf083bc02fd8e1f685804ecefe7d55462847c93badf44464f55a0fa6a8fc8aae839630efc00aaee30c9ad2a5b8f4410141bb17b29f312e2e1c2c963324776e7ea7ca90d717661a86d7da8f4cb6a72be1b8f979974032667733d3db07f528cb086f81edafe0a8ec28d890455fc8f382a79193e3d04284b9d0b13d181159191e8cd6401a592c464538a0145a88f8f2e5522ccc4aa3cf2779c2efe4d0dcb501f75011e063a4713eb3067a85761d79ed359db4a038fe2369f3b0d7aab29fd65aeabc3c408bbbfe9a03954d8a9af955d61e853b15183137bfb2654fc41aa9aaad6d4c68a6a034373e9600805ed0ab7a77c0ac9199d549c26c8bfa43ea449d45fe924fe728a98bc3f6575d8710012065ce72fc0fdea4e81b438fbd31afc4733bb15bc4d11cf103e89923bf04ff336c53c536a9456e8751233f8be29166e4a7982689988983bd351f875feea46a7a9875005f76e2e24213a7e6cc3456c22a9813e2b75cba3b1a282d6ab207e4eddba46992104a2ae4ccb2f5b6f728f42ae2f0a06e91c8772971e4169a5ee891d12465f673c3264b5619d5e05d97ee4d8da63fe9e9633af684fdf5193e47bf303621c2f5be35ef1e20f282c4d83bf03e
```

Note that ```len(message.toSerializeString())``` is ```271```. I fiddled around with ```msg```s of different lengths and found that a 266 character string does the trick.  

Checking the code again showed that the serialized messages were shifted and padded with some 24-bit psuedorandom value:
```Python
def get_padding():
    with open('/dev/urandom', 'rb') as f:
        return f.read(24)

def bytes_to_int(message):
    return int(message.encode('hex'), 16)
    # Python 3.x:
    # return int(message.hex(), 16)

def int_to_bytes(message):
    ms = hex(message)[2:].strip('L')
    if len(ms) % 2 != 0:
        ms = '0' + ms
    return ms.decode('hex')
    # Python 3.x
    # return bytes.fromhex(ms)

def unpad(mi):
    return mi >> 192

def pad(mi):
    return (mi << 192) | bytes_to_int(get_padding())

def encrypt(message):
    ciphertext = pow(pad(bytes_to_int(message)), publicExponent, modulus)
    return int_to_bytes(ciphertext)
```

### Time to Google!

I Googled "rsa attacks" and found this paper:
https://crypto.stanford.edu/~dabo/papers/RSA-survey.pdf

It looked like we could apply the Franklin-Reiter Related Message attack:

#### c<sub>1</sub> ≡ M<sub>1</sub><sup>e</sup> mod N
#### c<sub>2</sub> ≡ M<sub>2</sub><sup>e</sup> mod N = (M<sub>1</sub> + b)<sup>e</sup> mod N 

where ```b = id_delta + pad_delta```

```id_delta``` is the difference between the messages caused by serializing with different message.id values

```pad_delta``` is the difference between the messages as a result of the different 24-bit pad values 

Separating ```b``` into the known ```id_delta``` and relatively small & unknown ```pad_delta``` allows us to efficiently find ```pad_delta``` using Coppersmith's Theorem.

```id_delta``` could be computed by:
```Python
from Crypto.Util.number import bytes_to_long

zeros_266 = ''.join(['0' for i in range(266)])
mesg0 = Message(id=0, msg=zeroes_266)
mesg1 = Message(id=1, msg=zeroes_266)
id_delta = (bytes_to_long(mesg1) - bytes_to_long(mesg0)) << 192
```

### We're almost there...

With the following values:
```
c1 = bytes_to_long(bytes.fromhex(ct1))
c2 = bytes_to_long(bytes.fromhex(ct2))
id_delta = (bytes_to_long(mesg1) - bytes_to_long(mesg0)) << 192
e = 3
N = <from output.txt>
```

And a slightly modified Franklin-Reiter + Coppersmith implementation I found online:
```Python
def franklinReiter(n,e,a,b,c1,c2):
    R.<X> = Zmod(n)[]
    f1 = X^e - c1
    f2 = (a*X + b)^e - c2
    # coefficient 0 = -m, which is what we wanted!
    return Integer(n-(compositeModulusGCD(f1,f2)).coefficients()[0])

def compositeModulusGCD(a, b):
    if(b == 0):
        return a.monic()
    else:
        return compositeModulusGCD(b, a % b)

def CoppersmithShortPadAttack(e,n,C1,C2,id_delta, eps=1/30):
    P.<x,y> = PolynomialRing(ZZ)
    ZmodN = Zmod(n)
    g1 = x^e - C1
    # solving for y gives us pad_delta
    g2 = (x + id_delta + y)^e - C2
    res = g1.resultant(g2)
    P.<y> = PolynomialRing(ZmodN)
    rres = 0
    for i in range(len(res.coefficients())):
        rres += (res.coefficients()[i])*(y^(res.exponents()[i][1]))
    print('rres', rres)
    diff = rres.small_roots(beta=1, epsilon=eps)
    print('diff', diff)
    # pad_delta = diff[0]. We can now find M1 now that we know the relationship between M1 and M2
    recoveredM1 = franklinReiter(n,e,1,id_delta + diff[0],C1,C2)
    print('M1', recoveredM1)

c1 = 200947618902004293424824891201297697993833626832013220886837467886251752018143164235880011583468094645110722003593624284112219352074961433669401362658836461180216822614256744551458489618910133583890585094288060753239793621452589598154294322304785930843071962239406003856871364925028498972491882159281267623058095385652493874375185953451244095050531226602786737799040187151452370130360124565050543019914948765703133732764544431814363197233806989289427787198447859278428894358886184867612399691606578891257151164572273806602213948401130922160390076063191026075595352243037929402704184743224030573802212635382187932221917769489269136072284885247497755747133271871183784429877026698821255989546201990741048455187210371519569403990165601560813182741884817366778823620256701509927157594530968911357345197113934393225967989482124714867196738830528878293136360843246224996191030448171013963600008656643803536797032723899668053601373983632281583974930293124383587613517888223493201883590407325395913260066272909601097217844334516387865570017325214652284171852969690382953913663300562270141423971780466667143400237770794996706550971979012003212223333899072851029242546645950254250959915910618633846105280624342979772530392237019961419213891964
c2 = 47358007663821539849726077552648693438298122518350640132677840976217106649678466002255575962801888727862516988033097624878623470827480603474154638878581118946880622564505592626870116773274834115017060343050952953312357982866388847457996964334416985384153407809714159124597393576863029433467810354014295681343594100359696157873802292563961785735298948979752461235364595954161201101316364395080284198190213757737798855144490927880249522649652108933864097133187675720631295418154411494653628508071950709507280820017944267612763698062115464369101826751038899491898993225159380199996196230050413357364549991104296333123580025663547002675703609293132481670288584175743281517682520009191983398825207827835595589380073169155351911326995963597179035387232822698907915862309743319971429247295217826907864764120877859464115723266356820848274363794920140580651378262658081900707317376866548918154072934469370707527037615554449168782249437418767525597668260348441104975432184314130920934578087828855196040283997435102020036031765035289506714614171804210570632964247107780097471068669330434128345985245385892267671801526554284243772921570338621898061938453426893785462260781983604229538503355784828988302666559853452314766708879391778078090588222
e = 3
N  = 647353081512155557435109029192899887292162896024387438380717904550049084072650858042487538260409968902476642050863551118537014801984015026845895208603765204484721851898066687201063160748700966276614009722396362475860673283467894418696897868921145204864477937433189412833621006424924922775206256529053118483685827144126396074730453341509096269922609997933482099350967669641747655782027157871050452284368912421597547338355164717467365389718512816843810112610151402293076239928228117824655751702578849364973841428924562822833982858491919896776037660827425125378364372495534346479756462737760465746815636952287878733868933696188382829432359669960220276553567701006464705764781429964667541930625224157387181453452208309282139359638193440050826441444111527140592168826430470521828807532468836796445893725071942672574028431402658126414443737803009580768987541970193759730480278307362216692962285353295300391148856280961671861600486447754303730588822350406393620332040359962142016784588854071738540262784464951088700157947527856905149457353587048951604342248422901427823202477854550861884781719173510697653413351949112195965316483043418797396717013675120500373425502099598874281334096073572424550878063888692026422588022920084160323128550629
id_delta = 655466754302027714322819661568689458302857062813893029916810214032172464849991899428175362385124675671632003007392555317026101508464223851208913347457083249601766362030654880800282710668498531995907778757840049628217604377510433021835557203224514313665848349095370601982962298359506641352238071613054087474623714918561820888154293410637373426976653520488468705883155492711028085203492237042880640868734734404488445364849019662004572435975403272187135117187688869565578024111081791013364671988124090593819068611936862086379573149845116951662689306102910232920843992125347141732675898573395939496099143140718300114593292735560409641097394602163306496 << 192

CoppersmithShortPadAttack(e, N, c1, c2, id_delta)
```

I found M1!
```
M1 8426653674215996780199375946768354832391407925327286060984753229980527004629317825192564323850376174907919620077588713283091424863962024606351847463699214004292292442028324663546483764645754098746275725153113520871967109213265389525252720061670277994359807557256602169709023795905903256831512530626076862246303627306354106157782061586734590677179216043847026098716049052094681794106533955982880086940940965862418246260116758651423835237168517449637976621006599616421992678481409966146807210654264571414747104902912961568853121401822670064425342586135262705552705723566641246461593055825279429607165207774777998838423667817924773379375457676826273457269082759886623382093106486781793501099780175733289675994536
```

Unpadded and re-encoded as bytes (based on the provided ```pad``` and ```encrypt```)
```Python
def translate(m):
    plaintext = unpad(m)
    print(int_to_bytes(plaintext))

translate(M1)
```

And bam!
```
b'\x08\x00\x12\x8a\x02I never know what to put into these messages for CTF crypto problems. You gotta pad the length but flags can only reasonably be so long. Anyway, the flag should be coming any moment now... Ah, here it comes! The flag is: PCTF{w0w_such_p4d_v3ry_r34l1st1c_d0g3_crypt0}'
```
